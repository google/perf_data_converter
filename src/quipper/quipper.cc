// Copyright (c) 2012 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <cstdlib>
#include <string>

#include <gflags/gflags.h>
#include <gflags/gflags_declare.h>

#include "base/logging.h"

#include "compat/string.h"
#include "file_utils.h"
#include "perf_protobuf_io.h"
#include "perf_recorder.h"
#include "process_heap_profile.h"

namespace {

DEFINE_int64(duration, 0, "Duration to run perf in seconds");
DEFINE_string(perf_path, "", "Path to perf");
DEFINE_string(input_heap_profile, "", "Path to input heap profile");
DEFINE_int32(pid, -1,
             "Process ID from which the heap profile was extracted (only valid "
             "with --input_heap_profile)");
DEFINE_string(output_file, "/dev/stdout",
              "Path to store the output perf_data.pb.data");

bool ParsePerfArguments(int argc, char* argv[], int* duration,
                        std::vector<string>* perf_args, string* output_file) {
  if (FLAGS_pid >= 0 || !FLAGS_input_heap_profile.empty() || argc < 2) {
    return false;
  }

  *duration = FLAGS_duration;
  if (*duration <= 0) return false;

  string perf_path = FLAGS_perf_path;
  if (perf_path.empty()) return false;

  perf_args->emplace_back(perf_path);

  for (int i = 1; i < argc; i++) {
    perf_args->emplace_back(argv[i]);
  }

  *output_file = FLAGS_output_file;
  if (output_file->empty()) return false;

  return true;
}

bool RecordPerf(int perf_duration, const std::vector<string>& perf_args,
                const string& output_file) {
  quipper::PerfRecorder perf_recorder;
  string output_string;
  if (!perf_recorder.RunCommandAndGetSerializedOutput(perf_args, perf_duration,
                                                      &output_string)) {
    LOG(ERROR) << "Couldn't record perf";
    return false;
  }
  if (!quipper::BufferToFile(output_file, output_string)) {
    LOG(ERROR) << "Couldn't write perf_data.pb.data at " << output_file;
    return false;
  }
  return true;
}

bool ParseHeapArguments(string* heap_profile, string* output_file, int* pid) {
  std::vector<char> buffer;
  if (FLAGS_duration != 0 || !FLAGS_perf_path.empty() ||
      FLAGS_input_heap_profile.empty()) {
    return false;
  }

  if (!quipper::FileToBuffer(FLAGS_input_heap_profile, &buffer)) {
    LOG(ERROR) << "Couldn't read file " << FLAGS_input_heap_profile;
    return false;
  }

  heap_profile->assign(buffer.begin(), buffer.end());

  *output_file = FLAGS_output_file;
  if (output_file->empty()) return false;

  *pid = FLAGS_pid;
  if (*pid < 0) return false;

  return true;
}

bool ConvertHeapProfile(const string& heap_profile, int pid,
                        const string& output_file) {
  quipper::PerfDataProto perf_data_proto;
  if (!ProcessHeapProfile(heap_profile, pid, &perf_data_proto)) {
    LOG(ERROR) << "Couldn't parse the heap profile";
    return false;
  }
  if (!quipper::WriteProtobufToFile(perf_data_proto, output_file)) {
    LOG(ERROR) << "Couldn't write perf_data.pb.data at " << output_file;
    return false;
  }
  return true;
}

}  // namespace

// Usage is:
// To run perf using quipper and generate a perf_data.pb.data:
//   <exe> --duration <duration in seconds>
//         --perf_path <path to perf>
//         --output_file <path to store the output perf_data.pb.data>
//         --
//         <perf arguments>
// or to parse a heap profile generated by the gperftools tcmalloc's API
// GetHeapSample and generate a perf_data.pb.data:
//   <exe> --input_heap_profile <path to input heap profile>
//         --output_file <path to store the output perf_data.pb.data>
//         --pid <PID from which the heap profile was generated>
// (The synthesized perf_data.pb.data will be generated such that,
// once converted to a profile.proto using the perf_data_converter, should be
// equivalent to a profile.proto generated directly from the
// input_heap_profile using pprof.)

int main(int argc, char* argv[]) {
  gflags::ParseCommandLineFlags(&argc, &argv, true);

  std::vector<string> perf_args;
  string heap_profile, output_file;
  int perf_duration = 0, pid = 0;

  if (ParsePerfArguments(argc, argv, &perf_duration, &perf_args,
                         &output_file)) {
    return RecordPerf(perf_duration, perf_args, output_file) ? EXIT_SUCCESS
                                                             : EXIT_FAILURE;
  }

  if (ParseHeapArguments(&heap_profile, &output_file, &pid)) {
    return ConvertHeapProfile(heap_profile, pid, output_file) ? EXIT_SUCCESS
                                                              : EXIT_FAILURE;
  }

  LOG(ERROR) << "Invalid command line.";
  LOG(ERROR) << "Usage: " << argv[0] << " --duration <duration in seconds>"
             << " --perf_path <path to perf>"
             << " --output_file <path to store the output perf_data.pb.data>"
             << " -- <perf arguments>"
             << "\nor\n"
             << argv[0] << " --input_heap_profile <path to input heap profile>"
             << " --output_file <path to store the output perf_data.pb.data>"
             << " --pid <Process ID from which the heap profile was extracted "
             << "(only valid with --input_heap_profile)>";
  return EXIT_FAILURE;
}
