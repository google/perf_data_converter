// Copyright 2018 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "heap_profile_parser.h"

#include <cmath>  // for exp

#include <array>
#include <iomanip>
#include <string>

#include "base/logging.h"
#include "binary_data_utils.h"
#include "kernel/perf_internals.h"
#include "perf_data_utils.h"

using ::RE2;

namespace quipper {

namespace {

constexpr char kInuseSizeEventName[] = "heap_cpp_inuse_space";
constexpr char kInuseCountEventName[] = "heap_cpp_inuse_objects";

const u64 kInuseCountSampleID = 0;
const u64 kInuseSizeSampleID = 1;

const u64 kSampleTypes = PERF_SAMPLE_IP | PERF_SAMPLE_TID | PERF_SAMPLE_ID |
                         PERF_SAMPLE_PERIOD | PERF_SAMPLE_CALLCHAIN;

// ScaleSample adjusts the data from a heapz sample to account for its
// probability of appearing in the collected data. heapz profiles are a sampling
// of the memory allocation requests in a program. We estimate the unsampled
// value by dividing each collected sample by its probability of appearing in
// the profile. heapz v2 profiles rely on a Poisson process to determine which
// samples to collect, based on the desired average collection rate R. The
// probability of a sample of size S to appear in that profile is 1-exp(-S/R).
void ScaleSample(u64 sampling_period, u64* count, u64* size) {
  if (*count == 0 || *size == 0) {
    return;
  }

  if (sampling_period <= 1) {
    // if sample_period_==1, all samples were collected so no adjustment is
    // needed. if sample_period_<1, treat as unknown and skip scaling.
    return;
  }

  double avg_size = static_cast<double>(*size) / *count;
  double scale = 1 / (1 - exp(-avg_size / sampling_period));

  *count = static_cast<u64>(*count * scale);
  *size = static_cast<u64>(*size * scale);
}

}  // namespace

HeapProfileParser::HeapProfileParser(re2::StringPiece profile, u32 pid)
    : profile_(profile), pid_(pid) {
  // Initialize metadata mask bit to inform quipper that the generated
  // perf_data.proto would contain event descriptions.
  proto_.add_metadata_mask(1 << HEADER_EVENT_DESC);
}

void HeapProfileParser::ConsumeSpaceCommentOrNewLine() {
  static const LazyRE2 kSpaceCommentNewLineRegex = {R"(\s+|#.*\n|\n)"};
  while (RE2::Consume(&profile_, *kSpaceCommentNewLineRegex)) {
  }
}

bool HeapProfileParser::Parse() {
  static const LazyRE2 kMemoryMapSentinelRegex = {"MAPPED_LIBRARIES:"};
  if (!ParseHeader()) {
    return false;
  }
  ConsumeSpaceCommentOrNewLine();
  while (!profile_.empty() &&
         !RE2::Consume(&profile_, *kMemoryMapSentinelRegex)) {
    if (!ParseSample()) {
      return false;
    }
    ConsumeSpaceCommentOrNewLine();
  }

  if (samples_.empty()) {
    LOG(ERROR) << "No samples found.";
    return false;
  }

  ConsumeSpaceCommentOrNewLine();

  if (profile_.empty()) {
    LOG(ERROR) << "No mmaps found.";
    return false;
  }

  while (!profile_.empty()) {
    if (!ParseMemoryMapping()) {
      return false;
    }
    ConsumeSpaceCommentOrNewLine();
  }
  return true;
}

bool HeapProfileParser::ParseCountAndSize(u64* inuse_count, u64* inuse_size) {
  // Example count and size:
  // 171: 39868315 [   171: 39868315]
  u64 alloc_count = 0, alloc_size = 0;
  static const LazyRE2 kCountSizeRegex = {
      R"((\d+): *(\d+) *\[ *(\d+): *(\d+) *\] *@)"};
  if (!RE2::Consume(&profile_, *kCountSizeRegex, inuse_count, inuse_size,
                    &alloc_count, &alloc_size)) {
    LOG(ERROR) << "Invalid count and size entry";
    return false;
  }

  // Heapz profiles generated by the gperftools tcmalloc doesn't contain alloc
  // metrics. The parser should error when the alloc metrics are seen in a heapz
  // profile.
  if ((alloc_count != *inuse_count && alloc_count != 0) ||
      (alloc_size != *inuse_size && alloc_size != 0)) {
    LOG(ERROR) << "Alloc metrics are not expected in a heap profile";
    return false;
  }
  return true;
}

bool HeapProfileParser::ParseHeader() {
  // Example header:
  // heap profile:    171: 39868315 [   171: 39868315] @ heap_v2/524288
  static const LazyRE2 kVersionAndPeriodRegex = {
      R"(\s+(heap[_a-z0-9]*)/?(\d*))"};

  u64 count = 0, size = 0, period = 0;
  std::string version;

  if (!RE2::Consume(&profile_, "heap profile: *") ||
      !ParseCountAndSize(&count, &size) ||
      !RE2::Consume(&profile_, *kVersionAndPeriodRegex, &version, &period)) {
    LOG(ERROR) << "Invalid header entry";
    return false;
  }

  if (version != "heapz_v2" && version != "heap_v2") {
    LOG(ERROR) << "Unsupported heapz version";
    return false;
  }

  sampling_period_ = period;

  AddPerfFileAttr(/*sample_id=*/kInuseCountSampleID,
                  /*event_name=*/kInuseCountEventName);
  AddPerfFileAttr(/*sample_id=*/kInuseSizeSampleID,
                  /*event_name=*/kInuseSizeEventName);

  return true;
}

bool HeapProfileParser::ParseSample() {
  // Example sample entry:
  // 1:     8192 [     1:     8192] @ 0x617aae951c31 0x617aae95062e
  static const LazyRE2 kIPsRegex = {R"([\t\f ]+(?:0x)?([[:xdigit:]]+))"};

  u64 count = 0, size = 0;

  if (!ParseCountAndSize(&count, &size)) {
    LOG(ERROR) << "Invalid sample entry";
    return false;
  }

  std::vector<u64> ips;
  u64 ip = 0;

  // Read the IPs in the callstack.
  while (RE2::Consume(&profile_, *kIPsRegex, RE2::Hex(&ip))) {
    ips.push_back(ip);
  }

  if (ips.empty()) {
    LOG(ERROR) << "No callstack is available in the heap sample";
    return false;
  }

  if (count == 0 && size != 0) {
    LOG(ERROR) << "Inuse count was 0 but inuse size was " << size << " bytes.";
    return false;
  }

  ScaleSample(sampling_period_, &count, &size);

  // Emit two samples, each with the total events (either # allocations, or
  // bytes allocated) stored in 'period'. Since only 1 sample will be emitted,
  // the profile will look as though we pre-selected the sampling rate with a
  // period=${total}, such that there was just a single sample during our
  // profiling. This stores more densely than setting period=1 for the
  // number-of-allocations event type, and adding |count| sample events. (Or
  // similarly, period=size/count emitted |count| times for bytes allocated)
  AddSampleEvent(/*sample_id=*/kInuseCountSampleID, /*period=*/count, ips);
  AddSampleEvent(/*sample_id=*/kInuseSizeSampleID, /*period=*/size, ips);

  return true;
}

bool HeapProfileParser::ParseMemoryMapping() {
  // Example memory mapping entry:
  // 617aa770f000-617ab0689000 r-xp 00000000 00:00 98734
  // /opt/google/chrome/chrome
  static const LazyRE2 kPrefixRegex = {
      R"((?:0x)?([[:xdigit:]]+)[\s-](?:0x)?([[:xdigit:]]+)\s+([-r][-w][-x][-ps]))"
      R"(\s+(?:0x)?([[:xdigit:]]+)\s+[[:xdigit:]]+:[[:xdigit:]]+\s+[[:digit:]]+)"};
  static const LazyRE2 kFileRegex = {R"((?:[\t\f ]+([\S ]+))?)"};
  u64 start_addr = 0, end_addr = 0, offset = 0;
  re2::StringPiece permissions, load_module_path;

  // As a memory mapping entry may not have a file path, read the entry without
  // the file path.
  if (!RE2::Consume(&profile_, *kPrefixRegex, RE2::Hex(&start_addr),
                    RE2::Hex(&end_addr), &permissions, RE2::Hex(&offset))) {
    LOG(ERROR) << "Invalid memory map entry";
    return false;
  }

  // Attempt to read the file path.
  RE2::Consume(&profile_, *kFileRegex, &load_module_path);

  // Skip non-executable entries.
  if (permissions.find("x") != std::string::npos) {
    AddMmapEvent(start_addr, /*len=*/end_addr - start_addr, /*pgoff=*/offset,
                 /*filename=*/std::string(load_module_path));
  }

  return true;
}

void HeapProfileParser::AddPerfFileAttr(u64 sample_id,
                                        const std::string& event_name) {
  PerfDataProto_PerfFileAttr* file_attr = proto_.add_file_attrs();
  PerfDataProto_PerfEventAttr* event_attr = file_attr->mutable_attr();

  event_attr->set_type(PERF_TYPE_SOFTWARE);
  event_attr->set_size(PERF_ATTR_SIZE_VER3);
  event_attr->set_config(PERF_COUNT_SW_DUMMY);
  event_attr->set_sample_id_all(true);
  event_attr->set_sample_period(sampling_period_);
  event_attr->set_sample_type(kSampleTypes);
  // MMap bit is set to true only when sample id is 0.
  event_attr->set_mmap(sample_id == 0);

  file_attr->add_ids(sample_id);

  AddPerfEventType(event_attr->config(), event_name);
}

void HeapProfileParser::AddPerfEventType(u64 id,
                                         const std::string& event_name) {
  PerfDataProto_PerfEventType* event_type = proto_.add_event_types();

  event_type->set_id(id);
  event_type->set_name(event_name);
  event_type->set_name_md5_prefix(Md5Prefix(event_name));
}

void HeapProfileParser::AddEventHeader(u32 type, u32 misc,
                                       PerfDataProto_EventHeader* header) {
  header->set_type(type);
  header->set_misc(misc);
  // Event size is automatically populated during deserialize.
  header->set_size(0);
}

void HeapProfileParser::AddSampleEvent(u64 sample_id, u64 period,
                                       const std::vector<u64>& ips) {
  PerfDataProto_PerfEvent* event = samples_.Add();

  uint64_t callchain_size = ips.size();

  AddEventHeader(PERF_RECORD_SAMPLE, PERF_RECORD_MISC_USER,
                 event->mutable_header());

  PerfDataProto_SampleEvent* sample = event->mutable_sample_event();
  sample->set_ip(ips[0]);
  sample->set_pid(pid_);
  sample->set_tid(pid_);
  sample->set_id(sample_id);
  sample->set_period(period);

  sample->mutable_callchain()->Reserve(callchain_size + 1);
  // Linux perf adds a user context marker before user space callstack entries.
  sample->add_callchain(PERF_CONTEXT_USER);
  for (auto ip : ips) {
    sample->add_callchain(ip);
  }
}

void HeapProfileParser::AddMmapEvent(u64 start, u64 len, u64 pgoff,
                                     const std::string& filename) {
  PerfDataProto_PerfEvent* event = mappings_.Add();

  AddEventHeader(PERF_RECORD_MMAP, /*misc=*/0, event->mutable_header());

  PerfDataProto_MMapEvent* mmap = event->mutable_mmap_event();
  mmap->set_pid(pid_);
  mmap->set_tid(pid_);
  mmap->set_start(start);
  mmap->set_len(len);
  mmap->set_pgoff(pgoff);
  mmap->set_filename(filename);
  mmap->set_filename_md5_prefix(Md5Prefix(filename));

  PerfDataProto_SampleInfo* sample_info = mmap->mutable_sample_info();
  sample_info->set_pid(pid_);
  sample_info->set_tid(pid_);
  // MMaps aren't associated with any event and usually have sample id as 0.
  sample_info->set_id(0);
}

}  // namespace quipper
